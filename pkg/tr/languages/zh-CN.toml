"HugeSCM - A next generation cloud-based version control system" = "HugeSCM - 基于云的下一代版本控制系统"
"Show context-sensitive help" = "显示上下文相关的帮助"
"Make the operation more talkative" = "展示操作的更多细节"
"Set the path to the repository worktree" = "设置存储库的工作目录"
"Override default configuration, format: <key>=<value>" = "覆盖默认配置, 格式: <名称>=<取值>"
"Show version number and quit" = "展示版本信息并退出"
"Data will be returned in JSON format" = "返回数据将采用 JSON 格式"
"Enable debug mode; analyze timing" = "开启调试模式分析时间消耗"
"Commands:" = "命令："
"Arguments:" = "参数："
"Flags:" = "标志："
"Usage: " = "用法："
"   or: " = "  或："
"Aborting" = "正在终止"
"error: " = "错误："
"fatal: " = "致命错误："
"hint: " = "提示："
"warning: " = "警告："
# checkout
"Checkout remote, switch branches, or restore worktree files" = "检出远程，切换分支或还原工作区文件"
"Remote url or branch" = "远程 URL 或分支"
"Destination for the new repository" = "存储库的保存位置"
"A subset of repository files, all files are checked out by default" = "存储库文件的子集，默认检出所有文件"
"Get and checkout files for each provided on stdin" = "获取并检出标准输入上提供的每个文件"
"Checkout a non-editable snapshot" = "检出不可编辑的快照"
"Direct the new HEAD to the <name> branch after checkout" = "签出后将新 HEAD 定向到 <name> 分支"
"Direct the new HEAD to the <name> tag's commit after checkout" = "签出后将新 HEAD 定向到 <name> 标签对应的提交"
"Direct the new HEAD to the <name> ref's commit after checkout" = "签出后将新 HEAD 定向到 <name> 常规引用对应的提交"
"Direct the new HEAD to the <commit> branch after checkout" = "签出后将新 HEAD 定向到 <commit> 提交"
"Create a shallow clone with a history truncated to the specified number of commits" = "创建一个浅克隆，其历史记录被截断为指定的提交次数"
"Branch to checkout, HEAD by default" = "待检出的分支，默认为 HEAD"
"Omits blobs larger than n bytes or units. n may be zero. supported units: KB,MB,GB,K,M,G" = "省略大于 n 字节或单位的 blob。n 可能为零。支持的单位: KB,MB,GB,K,M,G"
"Operate quietly. Progress is not reported to the standard error stream" = "安静地操作。进度不会报告到标准错误流"
"Your local changes to the following files would be overwritten by checkout:" = "您对下列文件的本地修改将被检出操作覆盖："
"Please commit your changes or stash them before you switch branches." = "请在切换分支前提交或贮藏您的修改。"
"Checkout files" = "检出文件"
"Checkout files completed" = "检出文件完成"
"Checkout large files one after another" = "一个接着一个的检出大文件"
"Checkout large files one after another, --hard mode only" = "一个接着一个的检出大文件，仅限 --hard 模式"
"Start checkout large files, total: %d\n" = "开始检出大文件，总计: %d\n"
"Checkout '%s' success.\n" = "成功检出 '%s'。\n"
"Checkout one after another, total: %d\n" = "一个接着另一个的检出文件，总计：%d\n"
"The repository filesystem is '%s', which may affect zeta's operation." = "存储库文件系统为 '%s'，可能会影响 zeta 运行。"
# switch
"branch" = "分支"
"set up to track" = "设置为追踪"
"Switched to branch" = "切换至分支"
"Switched to a new branch" = "切换到一个新分支"
"Switch branches" = "切换分支"
"Branch to switch to and start-point" = "要切换的分支和 start-point"
"Create a new branch named <branch> starting at <start-point> before switching to the branch" = "在切换到分支之前，从 <start-point> 开始创建一个名为 <branch> 的新分支"
"Similar to --create except that if <branch> already exists, it will be reset to <start-point>" = "与 --create 类似，只是如果 <branch> 已经存在，它将被重置为 <start-point>"
"Create a new orphan branch, named <new-branch>. All tracked files are removed" = "创建一个新的孤立分支，命名为 <new-branch>。 所有跟踪的文件都将被删除"
"Switch to a commit for inspection and discardable experiments" = "切换到提交以进行检查和可丢弃的实验"
"Create and switch to a new branch based on a remote branch" = "基于远程分支创建并切换到新分支"
"Proceed even if the index or the working tree differs from HEAD" = "即使索引或工作树与 HEAD 不同也继续进行"
"An alias for --discard-changes" = "--discard-changes 的别名"
"Perform a 3-way merge with the new branch" = "和新的分支执行三方合并"
"Attempt to checkout from remote when branch is absent" = "当分支不存在时，尝试从远程检出"
"couldn't find branch '%s', add '--remote' download and switch to this branch" = "找不到分支 '%s'，添加 '--remote' 下载并切换到该分支"
"missing branch or commit argument" = "缺少分支或提交参数"
# fetch
"Download objects and reference from remote" = "从远程下载对象和引用"
"Reference or commit to be downloaded" = "待下载的引用或者提交"
"Get complete history" = "获取完整的历史"
"Download tags instead of branches only when refname is incomplete" = "仅当引用名不完全时，下载标签而不是分支"
"Override reference update check" = "覆盖引用检查"
"Metadata downloading" = "下载元数据"
"Metadata download completed, total" = "元数据下载完成，总计"
"Files download completed, total" = "文件下载完成，总计"
"time spent" = "耗时"
"total" = "总计"
"Batch download files" = "批量下载文件"
"Batch download files completed" = "批量下载文件完成"
"[up to date]" = "[最新]"
"[rejected]" = "[已拒绝]"
"unable to update local ref" = "不能更新本地引用"
"would clobber existing tag" = "会破坏现有的标签"
"[new tag]" = "[新标签]"
"[tag update]" = "[标签更新]"
"forced update" = "强制更新"
"non-fast-forward" = "非快进"
"fetch missing object error: %v" = "拉取缺失对象错误：%v"
"fetch target '%s' error: %v" = "拉取目标 '%s' 错误：%v"
# pull
"Fetch from and integrate with remote" = "从远程获取并与其集成"
"Specifies which branch to fetch and update" = "指定要获取和更新的分支"
"Allow fast-forward" = "允许快进"
"Abort if fast-forward is not possible" = "如果不能快进就放弃合并"
"Incorporate changes by rebasing rather than merging" = "使用变基操作取代合并操作以合入修改"
"Not possible to fast-forward, aborting." = "无法快进，终止。"
"Fast-forwarded %s to %s.\n" = "快进 %s 到 %s。\n"
"Please commit or stash them." = "请提交或贮藏修改。"
"Already up to date." = "已经是最新的。"
"Please enter a commit message to explain why this merge is necessary," = "请输入一个提交信息以解释此合并的必要性，尤其是将一个更新后的上游分支"
"especially if it merges an updated upstream into a topic branch." = "合并到主题分支。"
"Lines starting with '%c' will be ignored, and an empty message aborts." = "以 '%c' 开始的行将被忽略，而空的提交说明将终止提交。"
# commit
"Record changes to the repository" = "记录对存储库的更改"
"Use the given as the commit message. Concatenate multiple -m options as separate paragraphs" = "使用给定的作为提交说明。多个 -m 选项的值会作为独立段落合并"
"Take the commit message from the given file. Use - to read the message from the standard input" = "从给定文件中获取提交消息。 使用 - 从标准输入读取消息"
"Automatically stage modified and deleted files, but newly untracked files remain unaffected" = "让命令自动暂存已修改和删除的文件，但您未更踪的文件不受影响"
"Allow creating a commit with the exact same tree structure as its parent commit" = "允许创建一个与其父提交具有完全相同树结构的提交"
"Like --allow-empty this command is primarily for use by foreign SCM interface scripts" = "与 --allow-empty 一样，该命令主要供外部 SCM 接口脚本使用"
"Replace the tip of the current branch by creating a new commit" = "通过创建新的提交来替换当前分支的提示"
"Aborting commit due to empty commit message." = "终止提交因为提交说明为空。"
"Please enter the commit message for your changes. Lines starting\nwith '%c' will be ignored, and an empty message aborts the commit." = "请为您的变更输入提交说明。以 '%c' 开始的行将被忽略，而一个空的提交\n说明将会终止提交。"
# push
"Update remote refs along with associated objects" = "更新远程引用以及关联的对象"
"Option to transmit" = "传输选项"
"Update remote tag reference" = "更新远程标签引用"
"force updates" = "强制更新"
"Specify what destination ref to update with what source object" = "指定要使用哪个源对象更新哪个目标引用"
"unable to delete '%s': remote ref does not exist" = "错误：无法删除 '%s'：远程引用不存在"
"failed to push some refs to '%s'" = "无法推送一些引用到 '%s'"
"couldn't find remote ref %s" = "无法找到远程引用 %s"
"fetch remote reference '%s' error: %v" = "拉取远程引用 '%s' 错误: %v"
"upload large objects error: %v" = "上传大对象错误：%v"
"Push failed: %v" = "推送失败：%v"
"parse report error: %v" = "解析报告错误：%v"
# branch
"List, create, or delete branches" = "列出、创建或删除分支"
"Get and set repository or global options" = "获取和设置存储库或全局选项"
"List branches. With optional <pattern>..." = "列出分支，带有可选的 <pattern>..."
"Show current branch name" = "显示当前分支名"
"Copy a branch and its reflog" = "拷贝一个分支和它的引用日志"
"Copy a branch, even if target exists" = "拷贝一个分支，即使目标已存在"
"Delete branch (even if not merged)" = "移动/重命名一个分支，即使目标已存在"
"Delete fully merged branch" = "拷贝一个分支和它的引用日志"
"Move/rename a branch and its reflog" = "移动/重命名一个分支，以及它的引用日志"
"Move/rename a branch, even if target exists" = "移动/重命名一个分支，即使目标已存在"
"Force creation, move/rename, deletion" = "强制创建、移动/重命名、删除"
"'%s' is not a valid branch name" = "'%s' 不是一个有效的分支名称"
"'%s' exists; cannot create '%s'" = "'%s' 已存在，无法创建 '%s'"
"branch '%s' not found" = "分支 '%s' 未发现"
"cannot delete branch '%s' used by worktree at '%s'" = "无法强制更新被工作区 '%[2]s' 所使用的分支 '%[1]s'"
"Branch '%s' has been moved to '%s'\n" = "已经将分支 '%s' 移动到 '%s'\n"
"Deleted branch %s (was %s).\n" = "已删除分支 %s（曾为 %s）。\n"
# cat
"Provide contents or details of repository objects" = "提供存储库对象的内容或类型和大小信息"
"The name of the object to show" = "要显示的对象的名称。"
"Show object type" = "显示对象的类型"
"Show object size" = "显示对象的大小"
"Verify object hash" = "验证对象的哈希"
"Returns data as JSON; limited to commits, trees, fragments, and tags" = "仅提交、树、片段、标签数据以 JSON 格式返回"
"Converting text to Unicode" = "将文本转为 Unicode"
"View files directly" = "直接查看文件"
# config
"Name and value, support: <name value> appears in pairs or <name=value ...>, eg: zeta config K1=V1 K2=V2" = "名称和值，支持：<name value> 这样成对出现或者 <name=value ...>，举例：zeta config K1=V1 K2=V2"
"Use system config file" = "使用系统级配置文件"
"Only read or write to global ~/.zeta.toml" = "只读取或写入全局配置 ~/.zeta.toml"
"Only read or write to repository .zeta/zeta.toml, which is the default behavior when writing" = "只读取或写入存储库 .zeta/zeta.toml，这是写入时的默认行为"
"Remove the line matching the key from config file" = "从配置文件中删除与 Key 匹配的行"
"List all variables set in config file, along with their values" = "列出配置文件中设置的所有变量及其值"
"Get the value for a given Key" = "获取给定 Key 的值"
"Get all values for a given Key" = "获得给定 Key 所有的值"
"Add a new variable: name value" = "添加一个新的变量：名称 值"
"Terminate values with NUL byte" = "终止值是 NUL 字节"
"zeta config will ensure that any input or output is valid under the given type constraint(s), support: bool, int, float, date" = "zeta 配置将确保任何输入或输出在给定类型约束下有效, 支持类型: bool, int, float, date"
"only one config file at a time" = "一次只能有一个配置文件"
# tag
"List, create, or delete tags" = "列出、创建或删除标签"
"Annotated tag, needs a message" = "附注标签，需要一个说明"
"Take the tag message from the given file. Use - to read the message from the standard input" = "从给定文件中获取标签消息。 使用 - 从标准输入读取消息"
"List tags. With optional <pattern>..." = "列出标签，带有可选的 <pattern>..."
"Replace an existing tag with the given name (instead of failing)" = "用给定名称替换现有标签（而不是失败）"
"Use the given tag message (instead of prompting)" = "使用给定的标签消息（而不是提示）"
"Replace the tag if exists" = "如果存在，替换现有的标签"
"Delete tags" = "删除标签"
"'%s' is not a valid tag name." = "'%s' 不是一个有效的标签名称。"
"tag '%s' already exists" = "标签 '%s' 已存在"
"no tag message?" = "无标签说明？"
"Write a message for tag:" = "输入一个标签说明："
"Lines starting with '%c' will be ignored." = "以 '%c' 开头的行将被忽略。"
# log
"Show commit logs" = "显示提交日志"
"Show the working tree status" = "显示工作树状态"
"Give the output in the short-format" = "以短格式给出输出"
"Revision range" = "版本范围"
"Order by committer date" = "按提交时间排序，不遵循拓扑关系"
"Order by author date" = "按作者时间排序，不遵循拓扑关系"
"Reverse order" = "以相反的顺序输出"
"Follow only the first parent commit upon seeing a merge commit" = "看到合并提交后，仅关注第一个父提交"
# status
"(use \"zeta restore --staged <file>...\" to unstage)" = "（使用 \"zeta restore --staged <文件>...\" 以取消暂存）"
"Changes not staged for commit" = "尚未暂存以备提交的变更"
"(use \"zeta add <file>...\" to update what will be committed)" = "（使用 \"zeta add <文件>...\" 更新要提交的内容）"
"(use \"zeta restore <file>...\" to discard changes in working directory)" = "（使用 \"zeta restore <文件>...\" 丢弃工作区的改动）"
"no changes added to commit (use \"zeta add\" and/or \"zeta commit -a\")" = "修改尚未加入提交（使用 \"zeta add\" 和/或 \"zeta commit -a\"）"
"Untracked files" = "未跟踪的文件"
"(use \"zeta add <file>...\" to include in what will be committed)" = "（使用 \"zeta add <文件>...\" 以包含要提交的内容）"
"nothing added to commit but untracked files present (use \"zeta add\" to track)" = "提交为空，但是存在尚未跟踪的文件（使用 \"zeta add\" 建立跟踪）"
"new file:" = "新文件："
"copied:" = "拷贝："
"deleted:" = "删除："
"modified:" = "修改："
"renamed:" = "重命名："
"typechange:" = "类型变更："
"unknown:" = "未知："
"unmerged:" = "未合并："
"nothing to commit, working tree clean" = "无文件要提交，干净的工作区"
"On branch" = "位于分支"
"HEAD detached at" = "头指针分离于"
"Changes to be committed:" = "要提交的变更："
# version
"Display version information" = "显示版本信息"
"Also print build options" = "还打印构建选项"
"Run \"%s --help\" for more information." = "运行 \"%s --help\" 以获取更多信息。"
"Run \"%s <command> --help\" for more information on a command." = "运行 \"%s <command> --help\" 以获取有关命令的更多信息。"
# Add
"Add file contents to the index" = "添加文件内容至索引"
"Path specification, similar to Git path matching mode" = "路径规格，类似 Git 路径匹配模式"
"Dry run" = "演习"
"Update tracked files" = "更新已跟踪的文件"
"Add changes from all tracked and untracked files" = "添加所有改变的已跟踪文件和未跟踪文件"
"Override the executable bit of the listed files" = "覆盖列表里文件的可执行位"
"param '%s' must be either -x or +x" = "参数取值 '%s' 必须是 -x 或 +x"
"Nothing specified, nothing added." = "没有指定文件，也没有文件被添加。"
"hint: Maybe you wanted to say 'zeta add .'?" = "提示：也许您想要执行 'zeta add .'？"
# gc
"Cleanup unnecessary files and optimize the local repository" = "清除不必要的文件和优化本地仓库"
"Pack %s objects: loose object %d packed objects %d\n" = "打包 %s 对象：松散对象 %d 打包对象 %d\n"
"Pack %s objects: no smaller loose object, skipping packing.\n" = "打包 %s 对象：无较小松散对象，跳过打包。\n"
"Writing objects" = "写入对象"
"Prune objects" = "清理对象"
"completed" = "完成"
"Removed duplicate packages: %d, duplicate objects: %d empty dirs: %d\n" = "已删除重复的包：%d 重复对象：%d 空目录：%d\n"
"Pruning objects older than specified date (default is 2 weeks ago, configurable with gc.pruneExpire)" = "清理早于指定日期的孤立对象（默认为 2 周前，可通过 gc.pruneExpire 配置）"
# restore
"Restore files" = "恢复文件"
"Restore files completed" = "恢复文件完成"
"Which tree-ish to checkout from" = "要检出哪一个树"
"Restore working tree files" = "恢复工作区文件"
"Restore the index" = "恢复索引"
"Restore the working tree (default)" = "恢复工作区（默认）"
"Limits the paths affected by the operation" = "限制受操作影响的路径"
"SYNOPSIS" = "概要"
"Specify restore location. By default, restores working tree. Use --staged for index only, or both for both." = "指定恢复位置。默认情况下，恢复工作树。使用 --staged 仅恢复索引，或同时指定两者以恢复两者。"
"you must specify path(s) to restore" = "您必须指定要恢复的路径"
# reset
"Reset current HEAD to the specified state" = "将当前 HEAD 重置为指定状态"
"Reset HEAD and index" = "重置 HEAD 和索引"
"Reset only HEAD" = "仅重置 HEAD"
"Reset HEAD, index and working tree, changes discarded" = "重置 HEAD、索引和工作区，丢弃所有更改"
"Reset HEAD, index and working tree" = "重置 HEAD、索引和工作区"
"Reset HEAD but keep local changes" = "重置 HEAD 保留本地更改"
"Resets the current branch head to <commit>" = "重置当前分支 HEAD 到 <commit>"
"Unstaged changes after reset:" = "重置后取消暂存的变更："
"Fetch missing objects" = "获取丢失的对象"
"is now at" = "现在位于"
# clean
"Remove untracked files from the working tree" = "从工作树中移除未跟踪的文件"
"Remove whole directories" = "删除整个目录"
"Remove ignored files, too" = "也删除忽略的文件"
"force" = "强制"
"dry run" = "演习"
"Would remove" = "将删除"
"Removing" = "正删除"
"refusing to clean, please specify at least -f or -n" = "拒绝 clean，请至少指定 -f 或者 -n"
# ls-tree
"List the contents of a tree object" = "列出树对象的内容"
"Only show trees" = "只显示树"
"Recurse into subtrees" = "递归到子树"
"Show trees when recursing" = "当递归时显示树"
"Terminate entries with NUL byte" = "条目以 NUL 字符终止"
"Include object size" = "包括对象大小"
"List only filenames" = "只列出文件名"
"Use <n> digits to display object names" = "用 <n> 位数字显示对象名"
"ID of a tree-ish" = "ID 或者 tree 对象哈希"
"Given paths, show as match patterns; else, use root as sole argument" = "有路径时，显示为匹配模式；否则，使用根目录作为唯一路径参数"
# diff
"Show changes between commits, commit and working tree, etc" = "显示提交之间的更改、提交和工作树等"
"Compares two given paths on the filesystem" = "比较文件系统上给定的两个路径"
"Show only names of changed files" = "仅显示已更改文件的名称"
"Show names and status of changed files" = "显示已更改文件的名称和状态"
"Show numeric diffstat instead of patch" = "显示数字 diffstat 而不是补丁"
"Show diffstat instead of patch" = "显示 diffstat 而不是 patch"
"Output only the last line of --stat format" = "只输出--stat格式的最后一行"
"Output diff-raw with lines terminated with NUL" = "输出 diff-raw，行以 NUL 结尾"
"Compare the differences between the staging area and <revision>" = "比较暂存区和 <revision> 之间的差异"
"If --merge-base is given, use the common ancestor of <commit> and HEAD instead" = "如果给定 --merge-base，则使用 <commit> 与 HEAD 的共同祖先"
"Output to a specific file instead of stdout" = "输出到特定文件而不是 stdout"
"Generate a diff using the \"Histogram diff\" algorithm" = "使用 \"Histogram diff\" 算法生成差异"
"Generate a diff using the \"O(NP) diff\" algorithm" = "使用 \"O(NP) diff\" 算法生成差异"
"Generate a diff using the \"Myers diff\" algorithm" = "使用 \"Myers diff\" 算法生成差异"
"Generate a diff using the \"Patience diff\" algorithm" = "使用 \"Patience diff\" 算法生成差异"
"Choose a diff algorithm, supported: histogram|onp|myers|patience|minimal" = "选择一个 diff 算法，支持：histogram|onp|myers|patience|minimal"
"Spend extra time to make sure the smallest possible diff is produced" = "花费额外的时间来确保产生尽可能最小的差异"
# rm
"Remove files from the working tree and from the index" = "从工作树和索引中删除文件"
"Override the up-to-date check" = "忽略文件更新状态检查"
"Do not list removed files" = "不列出删除的文件"
"Only remove from the index" = "只从索引区删除"
"Allow recursive removal" = "允许递归删除"
# mv
"destination already exists, source=%s, destination=%s" = "目标已存在，源=%s，目标=%s"
# merge
"Join two development histories together" = "将两段发展史连在一起"
"Merge specific revision into HEAD" = "将特定的版本合并到 HEAD"
"Create a single commit instead of doing a merge" = "创建一个单独的提交而不是做一次合并"
"Merge commit message (for a non-fast-forward merge)" = "合并的提交说明（针对非快进式合并）"
"Allow merging unrelated histories" = "允许合并不相关的历史"
"Read message from file" = "从文件中读取提交说明"
"Add a Signed-off-by trailer" = "添加 Signed-off-by 尾注"
"Abort a conflicting merge" = "中止一个冲突的合并"
"Continue a merge with resolved conflicts" = "继续一个已解决冲突的合并"
"Your local changes to the following files would be overwritten by merge:" = "您对下列文件的本地修改将被合并操作覆盖："
"Please commit your changes or stash them before you merge." = "请在合并前提交或贮藏您的修改。"
"Automatic merge failed; fix conflicts and then commit the result." = "自动合并失败，修正冲突然后提交修正的结果。"
"Updating" = "更新"
"refusing to merge unrelated histories" = "拒绝合并无关的历史"
"No merge message -- not updating HEAD" = "无合并信息 -- 未更新 HEAD"
# rebase
"Reapply commits on top of another base tip" = "在另一个 base 之上重新应用提交"
"Rebase onto given branch" = "变基到给定的分支"
"Abort and checkout the original branch" = "终止并检出原有分支"
"Continue" = "继续"
"Successfully rebased and updated %s.\n" = "成功变基并更新 %s。\n"
"cannot rebase: You have unstaged changes." = "不能变基：您有未暂存的变更。"
# merge-tree
"Perform merge without touching index or working tree" = "执行合并而不触及索引和工作区"
"Specify a merge-base for the merge" = "指定用于合并的合并基线"
"If branches lack common history, merge-tree errors. Use this flag to force merge" = "如果分支无共同历史，合并会失败，这个标志用来绕过这个限制"
"Only output conflict-related file names" = "仅输出冲突相关的文件名"
"Convert conflict results to JSON" = "将冲突结果转换为 JSON"
"Auto-merging %s" = "自动合并 %s"
"warning: Cannot merge binary files: %s (%s vs. %s)" = "警告: 无法合并二进制文件: %s (%s vs. %s)"
"CONFLICT (%s): Merge conflict in %s" = "冲突（%s）：合并冲突于 %s"
"CONFLICT (distinct types): %s had different types on each side; renamed both of them so each can be recorded somewhere." = "冲突（不同类型）：%s 在两侧有不同的类型，将两者都重命名以便它们能记录在不同位置。"
"CONFLICT (rename/rename): %s renamed to %s in %s and to %s in %s." = "冲突（重命名/重命名）：%[1]s 重命名为 %[3]s 中的 %[2]s，以及在 %[5]s 中的 %[4]s。"
"CONFLICT (file/directory): directory in the way of %s from %s; moving it to %s instead." = "冲突（文件/目录）：目录已存在于 %[2]s 中的 %[1]s，将其移动到 %[3]s。"
"CONFLICT (modify/delete): %s deleted in %s and modified in %s." = "冲突（修改/删除）：%s 在 %s 中被删除，在 %s 中被修改。"
"content" = "内容"
"add/add" = "添加/添加"
# stash
"Stash the changes in a dirty working directory away" = "将脏工作目录中的更改暂存起来"
"Stash local changes and revert to HEAD" = "暂存本地更改并恢复到 HEAD"
"List the stash entries that you currently have" = "列出您当前拥有的暂存条目"
"Displays the diff of changes in a stash entry against the commit where it was created" = "显示暂存条目中的更改与创建它的提交的差异"
"Stashed untracked files with push/save, then cleaned with zeta clean" = "使用 push/save 存储未跟踪的文件，然后使用 zeta clean 清理"
"Remove all the stash entries" = "清除所有暂存条目"
"Remove a single stash entry from the list of stash entries" = "从存储条目列表中删除单个暂存条目"
"Apply and remove one stash" = "应用和删除一个暂存项"
"Like pop, but do not remove the state from the stash list" = "与 pop 类似，但不从暂存列表中删除状态"
"Attempt to recreate the index" = "尝试重建索引"
"No local changes to save" = "没有要保存的本地修改"
"No stash entries found." = "未发现贮藏条目。"
"'%s' is not a stash-like commit" = "'%s' 不像是一个贮藏提交"
# rev-parse
"Pick out and massage parameters" = "选择并解析参数"
"Show the working tree's root path (absolute by default)" = "显示工作树的根路径（默认为绝对路径）"
"Show the path to the .zeta directory" = "显示 .zeta 目录的路径"
"Field name to sort on" = "排序的字段名"
# for-each-ref 
"Output information on each ref" = "每个 ref 的输出信息"
"If given, only refs matching at least one pattern are shown" = "如果给定一个或多个模式，只显示与至少一个模式匹配的引用"
# show-ref
"reference does not exist" = "引用不存在"
# remote
"Manage of tracked repository" = "管理跟踪的存储库"
"Set URL for the remote" = "设置远程 URL"
"URL for the remote" = "远程的 URL"
"Gives some information about the remote" = "提供有关 remote 的一些信息"
# check-ignore
"Debug zetaignore / exclude files" = "调试 zetaignore/exclude 文件"
"Read file names from stdin" = "从标准输入读出文件名"
"Pathname given via the command-line" = "通过命令行给出的路径名"
"Terminate input and output records by a NUL character" = "输入和输出的记录使用 NUL 字符终结"
"Ignore index when checking" = "检查时忽略索引"
"cannot specify pathnames with --stdin" = "不能同时指定路径及 --stdin 参数"
"-z only makes sense with --stdin" = "不能同时指定路径及 --stdin 参数"
"no path specified" = "未指定路径"
# init
"Create an empty zeta repository" = "创建一个空 zeta 存储库"
"Override the name of the initial branch" = "覆盖初始分支名称"
"Initialize and start tracking a new repository" = "初始化并开始跟踪新存储库"
"Repository directory" = "存储库目录"
"Directory '%s' is already managed by zeta" = "目录 '%s' 已经由 zeta 管理"
# merge-base
"Find optimal common ancestors for merge" = "找到合并的最佳共同祖先"
"Output all common ancestors" = "输出所有共同的祖先"
"Is the first one ancestor of the other?" = "第一个是其他的祖先提交么？"
# ls-files
"Show information about files in the index and the working tree" = "显示索引和工作树中的文件信息"
"Show cached files in the output (default)" = "显示缓存的文件（默认）"
"Show deleted files in the output" = "显示已删除的文件"
"Show modified files in the output" = "显示已修改的文件"
"Show other files in the output" = "显示其它文件"
"Show staged contents' object name in the output" = "显示暂存区内容的对象名称"
# hash-object
"Compute hash or create object" = "计算哈希或者创建对象"
"Write the object into the object database" = "将对象写入对象数据库"
"Read the object from stdin" = "从标准输入读取对象"
"Process file as it were from this path" = "处理文件并假设其来自于此路径"
# merge-file
"Run a three-way file merge" = "运行三向文件合并"
"Send results to standard output" = "将结果发送到标准输出"
"Use object IDs instead of filenames" = "使用对象 ID 替换文件名"
"Use a diff3 based merge" = "使用基于 diff3 的合并"
"Use a zealous diff3 based merge" = "使用基于狂热 diff3（zealous diff3）的合并"
"Set labels for file1/orig-file/file2" = "为 文件1/初始文件/文件2 设置标签"
# show
"Show various types of objects" = "显示各种类型的对象"
# replay
"EXPERIMENTAL: Apply the changes introduced by some existing commit" = "EXPERIMENTAL: 应用一些现有提交引入的更改"
"EXPERIMENTAL: Revert commit" = "EXPERIMENTAL: 撤销提交"
"Existing commit" = "存在的 commit"
# rename
"EXPERIMENTAL: Rename a file" = "EXPERIMENTAL: 重命名文件"
"Force rename even if target exists" = "强制重命名，即使目标存在"
"Skip rename errors" = "跳过重命名错误"
# Others
"WARNING" = "警告"
"not zeta repository" = "不是 zeta 存储库"
"this operation must be run in a work tree" = "操作必须在一个工作区中运行"
"Checkout into '%s'...\n" = "正检出到 '%s'...\n"
"is an absolute path and cannot be set as a sparse dir." = "是绝对路径，不能设置为稀疏目录。"
"postflight: remove large files in extreme mode: %d, reduce: %s." = "postflight: 极端模式下移除大文件：%d, 节省空间：%s."
"ambiguous argument '%s': unknown revision or path not in the working tree." = "有歧义的参数 '%s'：未知的版本或路径不存在于工作区中。"
"destination path '%s' already exists and is not an empty directory." = "目标路径 '%s' 已经存在，并且不是一个空目录。"
# web
"Too many failed attempts" = "失败次数过多"
"Redirecting %s\n" = "重定向到 %s\n"
"too many redirects" = "太多重定向"
"notice: %s\n" = "注意：%s\n"
#### extra tools
"zeta-mc - Migrate Git repository to zeta" = "zeta-mc - 将 Git 存储库迁移到 zeta"
"Original repository remote URL (or filesystem path)" = "原始存储库远程 URL（或文件系统路径）"
"Destination where the repository is migrated" = "迁移完的存储库目的地"
"Squeeze mode, compressed metadata" = "压缩模式, 压缩元数据（默认不压缩）"
"Migrate all LFS objects to zeta" = "将所有 LFS 对象迁移至 zeta"
"Migrate Blobs" = "迁移文件"
"Rewrite commits" = "重写提交"
"Rewrite references" = "重写引用"
"processing completed" = "处理完成"
"Migrate '%s' from git to zeta success, spent: %v\n" = "成功将 '%s' 从 git 迁移到 zeta, 耗时: %v\n"
"Upload Large files" = "上传大文件"
"Upload Fragments" = "上传切片"
"Download Objects" = "下载对象"
"Downloading" = "下载"
"retrying" = "重试中"
"Author identity unknown" = "作者身份未知"
"*** Please tell me who you are." = "*** 请告诉我您是谁。"
"Run" = "运行"
"to set your account's default identity." = "来设置您账号的缺省身份标识。"
"Omit --global to set the identity only in this repository." = "如果仅在本仓库设置身份标识，则省略 --global 参数。"
"Cherry-pick failed; fix conflicts and then commit the result." = "挑选失败；修正冲突然后提交修正的结果。"
"Revert failed; fix conflicts and then commit the result." = "还原失败；修正冲突然后提交修正的结果。"
